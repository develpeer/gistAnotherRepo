# the one and only Dev.E.L'Peer  https://github.com/develpeer
##
# A bunch of examples explaining lists and related 
# concepts like iterators and generators in python
##

import math

########################################################
# Understanding list splicing, insertion
########################################################
list_1 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
print(f"Before prepend list_1 : {list_1}")
list_1[:0] = [666]
print(f"After prepend list_1 : {list_1}")
list_1 = [665] + list_1
print(f"After prepend list_1 : {list_1}")
list_1[:] = 664, *list_1
print(f"After prepend list_1 : {list_1}")
list_1.insert(0, 663)
print(f"After prepend list_1 : {list_1}")
list_1.insert(2, 664.5)
print(f"After insert list_1 : {list_1}")
list_1[4:4] = 655.5,
print(f"After insert list_1 : {list_1}")

########################################################
# 5.1.3. List Comprehensions
# List comprehensions provide a concise way to create lists. 
# Common applications are to make new lists where each element 
# is the result of some operations applied to each member of another 
# sequence or iterable, or to create a subsequence of those elements 
# that satisfy a certain condition.
########################################################
print("-=-" * 25)
# Square all digits using a generator
print([x ** 2 for x in range(10)])
# Square all even digits
print([(x, x ** 2) for x in range(10) if not x % 2])

####
# this expression is a generator..and the next() function 
# gets successive elements of the generetor 
###
gee = (x * 2 for x in range(10))
print(next(gee))  # first element
print(next(gee))  # second element
print(*gee)  # remaining elements


####
# Using a custom generator
####
from fibonacci_generator import fibonacci_using_generators
print(f"This is a list created from a fibonacci sequence of length 20 {[*fibonacci_using_generators(20)]}")
fibg = fibonacci_using_generators(20) #this is an infinte series
for i in range(1,6):
    next(fibg) #ignore the first 5 values
print(f"This is a list created using the 6th value generated by the generator {[next(fibg)]}")
print(f"This is a list created using the 7th to  10th value generated by the generator {[ next(fibg) for x in range(1,5)]}")
#list constructors only take one parameter.. an iterator
print(f"This is a list created using the remaining items in the above generator {list(fibg)}")
print(f"This is a list created using the a new generator {list(fibonacci_using_generators(5))}")
print(f"This is a list created using the list constructor and string {list('amit')}")


####
# understanding list equality
####
t = ("hello", None)
print(t)
u = ("hello",)
v = ("hello",)

print(t == v, u == v)


########################################################
# Understanding maps and lambda functions
# lambda functions are just shortcut functions.
# Maps take two arguments a function, and a list, and
# then map the function to members of the list (or maybe even a tuple?)
########################################################
def doubler(i):
    return i*2

doubler_using_lambda=lambda j: j*2

#creating lists using the methods above, [] with unpacking, and list constructor
print(f"New list with [unpacked map with defined function]= {[*map(doubler,range(4,14))]}")
print(f"New list with [unpacked map with lambda]= {[*map(doubler_using_lambda,range(4,14,1))]}")
print(f"New list with list constructor with map with defined function]= {list(map(doubler_using_lambda,range(4,14,1)))}")
print(f"New list with list constructor with map with lambda]= {list(map(doubler_using_lambda,range(4,14,1)))}")
print(f"New list with shorthand lambda= {list(map(lambda j: j*2,range(4,14,1)))}")